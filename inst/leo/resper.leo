<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="12" clone_windows="0"/>
<globals body_outline_ratio="0.465665236052">
	<global_window_position top="65" left="25" height="585" width="932"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="hannes.20050214061735" a="E"><vh>Sampling from restricted permutations</vh>
<v t="hannes.20050217075724" a="E" tnodeList="hannes.20050217075724,hannes.20050217081922,hannes.20050217081922.1,hannes.20050217081922.2,hannes.20050217082529,hannes.20050217081922.3,hannes.20050217081922.4,hannes.20050217081922.5,hannes.20050217081922.6,hannes.20050512202734"><vh>@nosent ../../DESCRIPTION</vh>
<v t="hannes.20050217081922"><vh>&lt;&lt; Package &gt;&gt;</vh></v>
<v t="hannes.20050217081922.1"><vh>&lt;&lt; Title &gt;&gt;</vh></v>
<v t="hannes.20050217081922.2" a="TV"><vh>&lt;&lt; Version &gt;&gt;</vh></v>
<v t="hannes.20050217082529"><vh>&lt;&lt; Date &gt;&gt;</vh></v>
<v t="hannes.20050217081922.3"><vh>&lt;&lt; Author &gt;&gt;</vh></v>
<v t="hannes.20050217081922.4"><vh>&lt;&lt; Description &gt;&gt;</vh></v>
<v t="hannes.20050217081922.5"><vh>&lt;&lt; Maintainer &gt;&gt;</vh></v>
<v t="hannes.20050217081922.6"><vh>&lt;&lt; License &gt;&gt;</vh></v>
<v t="hannes.20050512202734"><vh>&lt;&lt; Encoding &gt;&gt;</vh></v>
</v>
<v t="hannes.20050214061735.1" a="E" tnodeList="hannes.20050214061735.1,hannes.20050214061735.2,hannes.20050214061735.3,hannes.20050214061735.4,hannes.20050214061735.5,hannes.20050214062217,hannes.20050214062217.1,hannes.20050214062217.2,hannes.20050217062348"><vh>@nosent ../../R/helper.R</vh>
<v t="hannes.20050214061735.2" a="E"><vh>The recursive function</vh>
<v t="hannes.20050214061735.3"><vh>The recursive definition</vh></v>
<v t="hannes.20050214061735.4"><vh>A non-recursive version</vh></v>
<v t="hannes.20050214061735.5"><vh>The wrapper function</vh></v>
</v>
<v t="hannes.20050214062217" a="E"><vh>The selection probability</vh>
<v t="hannes.20050214062217.1"><vh>Upper bound for the permanent</vh></v>
<v t="hannes.20050214062217.2"><vh>Vector of selection weights</vh></v>
</v>
<v t="hannes.20050217062348"><vh>generate a tube matrix from a sequence</vh></v>
</v>
<v t="hannes.20050216053950" tnodeList="hannes.20050216053950,hannes.20050214063138,hannes.20050214065037,hannes.20050214065906,hannes.20050214063138.1,hannes.20050214063710"><vh>@nosent ../../R/byrow-sample.R</vh>
<v t="hannes.20050214063138"><vh>Huber's accept and reject algorithm</vh>
<v t="hannes.20050214065037" a="E"><vh>&lt;&lt;try and sample until proper permutation is chosen&gt;&gt;</vh>
<v t="hannes.20050214065906" a="E"><vh>&lt;&lt;see how far you get without failing&gt;&gt;</vh>
<v t="hannes.20050214063138.1" a="M"><vh>&lt;&lt;random sample column&gt;&gt;</vh></v>
<v t="hannes.20050214063710" a="M"><vh>&lt;&lt;reduce matrix to sampled minor&gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="hannes.20050216053950.1" tnodeList="hannes.20050216053950.1,hannes.20050214071713,hannes.20050217094742.5,hannes.20050214072408,hannes.20050214072408.1,hannes.20050214072408.2,hannes.20050214072802,hannes.20050214073943,hannes.20050214074544,hannes.20050214080843,hannes.20050214080843.1,hannes.20050214080843.2,hannes.20050214081550,hannes.20050214081952,hannes.20050214083309,hannes.20050214074544.2"><vh>@nosent ../../R/clot-sample.R</vh>
<v t="hannes.20050214071713" a="E"><vh>The separating accept-reject</vh>
<v t="hannes.20050217094742.5"><vh>&lt;&lt; Details &gt;&gt;</vh></v>
<v t="hannes.20050214072408" a="E"><vh>Selection criteria for separator</vh>
<v t="hannes.20050214072408.1"><vh>Preference for "waists" </vh></v>
<v t="hannes.20050214072408.2"><vh>Preference for middle elements</vh></v>
<v t="hannes.20050214072802"><vh>Combining the criteria</vh></v>
</v>
<v t="hannes.20050214073943"><vh>Detecting the block-structure</vh></v>
<v t="hannes.20050214074544" a="E"><vh>The inner function</vh>
<v t="hannes.20050214080843" a="E"><vh>&lt;&lt;try and sample until proper permutation&gt;&gt;</vh>
<v t="hannes.20050214080843.1" a="E"><vh>&lt;&lt;see how far you get without failing&gt;&gt;</vh>
<v t="hannes.20050214080843.2"><vh>&lt;&lt;sample from unrestricted set of permutations&gt;&gt;</vh></v>
<v t="hannes.20050214081550"><vh>&lt;&lt;call function recursively on the blocks&gt;&gt;</vh></v>
<v t="hannes.20050214081952"><vh>&lt;&lt;select row and column to delete&gt;&gt;</vh></v>
<v t="hannes.20050214083309"><vh>&lt;&lt;reduce matrix to minors&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="hannes.20050214074544.2" a="E"><vh>The wrapper function</vh></v>
</v>
</v>
<v t="hannes.20050217062348.2" a="E"><vh>functions to be exported</vh>
<v t="hannes.20050214063138"><vh>Huber's accept and reject algorithm</vh>
<v t="hannes.20050214065037" a="E"><vh>&lt;&lt;try and sample until proper permutation is chosen&gt;&gt;</vh>
<v t="hannes.20050214065906" a="E"><vh>&lt;&lt;see how far you get without failing&gt;&gt;</vh>
<v t="hannes.20050214063138.1" a="M"><vh>&lt;&lt;random sample column&gt;&gt;</vh></v>
<v t="hannes.20050214063710" a="M"><vh>&lt;&lt;reduce matrix to sampled minor&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="hannes.20050214074544.2"><vh>The wrapper function</vh></v>
<v t="hannes.20050217062348"><vh>generate a tube matrix from a sequence</vh></v>
<v t="hannes.20050217060342" tnodeList="hannes.20050217060342"><vh>@nosent ../../NAMESPACE</vh></v>
<v t="hannes.20050217083718" a="E"><vh>Documentation on the exported functions</vh>
<v t="hannes.20050217083718.1" a="E" tnodeList="hannes.20050217083718.1,hannes.20050512202734,hannes.20050217084055,hannes.20050217084055.1,hannes.20050217085507.1,hannes.20050217085507.2,hannes.20050217100004,hannes.20050217092622.1,hannes.20050217081922.3,hannes.20050217092646,hannes.20050217085507,hannes.20050217092459"><vh>@file ../../man/ResperByrow.Rd</vh>
<v t="hannes.20050512202734"><vh>&lt;&lt; Encoding &gt;&gt;</vh></v>
<v t="hannes.20050217084055"><vh>&lt;&lt; Title &gt;&gt;</vh></v>
<v t="hannes.20050217084055.1"><vh>&lt;&lt; Description &gt;&gt;</vh></v>
<v t="hannes.20050217085507.1" a="E"><vh>&lt;&lt; Arguments &gt;&gt;</vh>
<v t="hannes.20050217085507.2" a="E"><vh>&lt;&lt; mat &gt;&gt;</vh></v>
</v>
<v t="hannes.20050217100004"><vh>&lt;&lt; Details &gt;&gt;</vh></v>
<v t="hannes.20050217092622.1"><vh>&lt;&lt; Value &gt;&gt;</vh></v>
<v t="hannes.20050217092646"><vh>&lt;&lt; Notes &gt;&gt;</vh></v>
<v t="hannes.20050217085507"><vh>&lt;&lt; See Also &gt;&gt;</vh></v>
<v t="hannes.20050217081922.3"><vh>&lt;&lt; Author &gt;&gt;</vh></v>
<v t="hannes.20050217092459"><vh>&lt;&lt; Examples &gt;&gt;</vh></v>
</v>
<v t="hannes.20050217094742" a="E" tnodeList="hannes.20050217094742,hannes.20050512202734,hannes.20050217094742.1,hannes.20050217094742.2,hannes.20050217094742.3,hannes.20050217094742.4,hannes.20050217094742.5,hannes.20050217094742.6,hannes.20050217081922.3,hannes.20050217094742.7,hannes.20050217094742.8,hannes.20050217094742.10"><vh>@file ../../man/ResperClot.Rd</vh>
<v t="hannes.20050512202734"><vh>&lt;&lt; Encoding &gt;&gt;</vh></v>
<v t="hannes.20050217094742.1" a="E"><vh>&lt;&lt; Title &gt;&gt;</vh></v>
<v t="hannes.20050217094742.2"><vh>&lt;&lt; Description &gt;&gt;</vh></v>
<v t="hannes.20050217094742.3" a="E"><vh>&lt;&lt; Arguments &gt;&gt;</vh>
<v t="hannes.20050217094742.4"><vh>&lt;&lt; mat &gt;&gt;</vh></v>
</v>
<v t="hannes.20050217094742.5" a="M"><vh>&lt;&lt; Details &gt;&gt;</vh></v>
<v t="hannes.20050217094742.6"><vh>&lt;&lt; Value &gt;&gt;</vh></v>
<v t="hannes.20050217094742.7"><vh>&lt;&lt; Notes &gt;&gt;</vh></v>
<v t="hannes.20050217094742.8"><vh>&lt;&lt; See Also &gt;&gt;</vh></v>
<v t="hannes.20050217081922.3"><vh>&lt;&lt; Author &gt;&gt;</vh></v>
<v t="hannes.20050217094742.10"><vh>&lt;&lt; Examples &gt;&gt;</vh></v>
</v>
<v t="hannes.20050222080110" a="E" tnodeList="hannes.20050222080110,hannes.20050512202734,hannes.20050222080315,hannes.20050222080839,hannes.20050222080839.1,hannes.20050222080839.2,hannes.20050222080839.3,hannes.20050222081106,hannes.20050222081106.1,hannes.20050217081922.3,hannes.20050222082057,hannes.20050222082057.1,hannes.20050222170736"><vh>@file ../../man/WithinDeltaMat.Rd</vh>
<v t="hannes.20050512202734"><vh>&lt;&lt; Encoding &gt;&gt;</vh></v>
<v t="hannes.20050222080315" a="E"><vh>&lt;&lt; Title &gt;&gt;</vh></v>
<v t="hannes.20050222080839" a="E"><vh>&lt;&lt; Description &gt;&gt;</vh></v>
<v t="hannes.20050222080839.1" a="E"><vh>&lt;&lt; Arguments &gt;&gt;</vh>
<v t="hannes.20050222080839.2"><vh>&lt;&lt; seq &gt;&gt;</vh></v>
<v t="hannes.20050222080839.3"><vh>&lt;&lt; delta &gt;&gt;</vh></v>
</v>
<v t="hannes.20050222081106" a="E"><vh>&lt;&lt; Details &gt;&gt;</vh></v>
<v t="hannes.20050222081106.1" a="E"><vh>&lt;&lt; Value &gt;&gt;</vh></v>
<v t="hannes.20050222082057"><vh>&lt;&lt; Notes &gt;&gt;</vh></v>
<v t="hannes.20050222082057.1" a="E"><vh>&lt;&lt; See Also &gt;&gt;</vh></v>
<v t="hannes.20050217081922.3" a="E"><vh>&lt;&lt; Author &gt;&gt;</vh></v>
<v t="hannes.20050222170736" a="E"><vh>&lt;&lt; Examples &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="hannes.20050329072710" a="E"><vh>tests</vh>
<v t="hannes.20050214061735.4"><vh>A non-recursive version</vh></v>
<v t="hannes.20050329072710.1"><vh>Test for Huber function</vh></v>
<v t="hannes.20050214062217.2"><vh>Vector of selection weights</vh></v>
<v t="hannes.20050329074025"><vh>Test for vector of selection weights</vh></v>
<v t="hannes.20050329073523" a="E" tnodeList="hannes.20050329073523,hannes.20050329072710.1,hannes.20050329074025"><vh>@nosent ../../tests/resper-tests.R</vh>
<v t="hannes.20050329072710.1"><vh>Test for Huber function</vh></v>
<v t="hannes.20050329074025"><vh>Test for vector of selection weights</vh></v>
</v>
</v>
<v t="hannes.20050323152429"><vh>Vignettes</vh>
<v t="hannes.20050323152429.1" tnodeList="hannes.20050323152429.1"><vh>@asis ../doc/huber-sim.Rnw</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="hannes.20050214061735"></t>
<t tx="hannes.20050214061735.1">@
\subsection{Auxiliary functions}
\label{sec:helper}

@c
@others

</t>
<t tx="hannes.20050214061735.2">@
\subsection{The recursive function}
\label{sec:recfun}</t>
<t tx="hannes.20050214061735.3">@
The novelty introduced by Huber is the variation of a
bound of the permanent from above \cite{bregman1973} that works as a probability: The
value of a function of a matrix is always at least as big as the sum
of the values of the function of the minors, developed around a column
of the matrix. It is the recursive function on the dimension $n$ of
the matrix: 
\begin{eqnarray}
  \label{eq:huberg}
  G(n) := 
  \begin{cases}
     \text{e} &amp; \text{for }n=1 \\
      G(n-1)+1+0.5/G(n-1)+0.6/G(n-1)^2 &amp; \text{for }n&gt;1
  \end{cases}    
\end{eqnarray}
@c

HuberGInner &lt;- function(n) {
    if (n == 1) 
        exp(1)
    else {
        gnm &lt;- HubergGInner(n - 1)
        gnm + 1 + 0.5/gnm + 0.6/gnm/gnm
    }
}
 
</t>
<t tx="hannes.20050214061735.4">@
R does not like recursion too much, so a non-recursive version is
employed here: 
@c
HuberGNonRecursive &lt;- function(n) {
    for (i in 1:n) {
        if (i == 1) 
            gnm &lt;- exp(1)
        else gnm &lt;- gnm + 1 + 0.5/gnm + 0.6/gnm/gnm
    }
    gnm
}
</t>
<t tx="hannes.20050214061735.5">@ 

A wrapper for the function is used that checks for valid entries:

@c
HuberGE &lt;- function(n) {
    if (n &gt; floor(n)) {
        stop("n must be of integer value")
    }
    else if (n &lt; 0) {
        stop("n must be at least 1")
    }
    else if (n == 0) 
        0
    else {
        HuberGNonRecursive(n)/exp(1)
    }
}
</t>
<t tx="hannes.20050214062217">@
\subsection{The selection probability}
\label{sec:selectprob}</t>
<t tx="hannes.20050214062217.1">@ 

The actual probability is given by 
\begin{eqnarray}
  \label{eq:permboundary}
  M(A) &amp; := &amp; \prod_i G(c_i) ,
\end{eqnarray}
where $c_i$ is
the sum of the $i$th column (i.e. the number of ones in it).

@c
###  Formula (3)
PermBound &lt;- function(mat) {
        prod(sapply(apply(mat, 2, sum), HuberGE))
}
</t>
<t tx="hannes.20050214062217.2">@ 

As said, this is a probability because
\begin{eqnarray}
  \label{eq:probability}
  M(A) \ge \sum_j a_{ij} M(A(\breve{\imath}, \breve{\jmath})) \quad\forall\quad i.
\end{eqnarray}
 The \verb+drop=FALSE+ argument retains the array structure even if the dimension of the matrix is 1 (see \cite{R-FAQ}). The vector of the above sum elements is needed to sample a row for a given column. The function pastes the difference of the sum of these elements from one to the end.

@c
HuberProbs &lt;- function(at, i) {
    n &lt;- nrow(at)
    Mrt &lt;- sapply(1:n, function(j) {
        if (at[i, j] &gt; 0) {
            PermBound(at[-i, -j, drop=FALSE])
        }
        else {
            0
        }
    })
    c(Mrt, PermBound(at) - sum(Mrt))
}
</t>
<t tx="hannes.20050214063138">@ 

The following function runs the algorithm described in
\cite{huber2003}. It picks the first row of the matrix and randomly
selects a column, where the sample elements are weighted by the
probability formula given above. If the last element of the sampling
vector is selected (the one that has fills up the probability sum to
one), the whole sample is rejected and restarted. This is accomplished
by a \verb+repeat+ loop encapsulated by another \verb+repeat+ loop,
and the Boolean variable \verb+accept+. The outermost loop is broken
out of iff \verb+accept==TRUE+. 
@c
###  Algorithm from Figure 2    
ResperByrow &lt;- function(mat) {
  reject &lt;- 0
  repeat { # the outer loop; exited after proper sample
    &lt;&lt;try and sample until proper permutation is chosen&gt;&gt;
  }
  list(perm=perm, reject=reject)
}
</t>
<t tx="hannes.20050214063138.1">@
First, create the vector of sample weights (permanent bounds of
all the minors), including
the extra element that completes the sum so that it 
equals the permanent bound of the current matrix.
Then, sample and reject if this extra element is selected.
@c 
Mrt &lt;- HuberProbs(at, 1)
elt &lt;- sample(n+1, 1, prob=Mrt)
if (elt==n+1) {
  accept &lt;- FALSE
  break
}
          </t>
<t tx="hannes.20050214063710">at &lt;- at[-1, -elt]
indizes &lt;- indizes[-elt]
</t>
<t tx="hannes.20050214065037">@
The accept flag is initialized to \verb+TRUE+, the row sums and dimension
are calculated, and the indices are initialized as a reference. These are 
needed because the matrix is reduced to its minors later, to maintain the
reference from the column of a minor to the column of the matrix. Then
the inner loop is entered. This \verb+repeat+ loop can be broken out of 
successfully (if a permutation is complete) or with a failure (if a 
permutation failed to be sampled). If it is exited successfully, exit 
this loop also, if not, increment the variable \verb+reject+, re-initialize and re-enter the inner loop.
The
variable \verb+reject+ records the number of failures. It is returned with the permutation in a
common data structure.
@c
accept &lt;- TRUE
at &lt;- mat
rt &lt;- apply(at, 1, sum)
n &lt;- nrow(at)
rownames(at) &lt;- colnames(at) &lt;- 1:n
indizes &lt;- 1:n
perm &lt;- NULL
repeat { # the inner loop; exited on failed sample for retry
  &lt;&lt;see how far you get without failing&gt;&gt;
}   
if (accept) break else {
  reject &lt;- reject+1
}
</t>
<t tx="hannes.20050214065906">@
Failures within this loop can occur if the matrix includes 
a zero row, or if the random sampling process selects the
``column'' beyond the matrix.

If a column of the matrix is sampled, the vector of permutation is
extended by the selected column. Note that the column number has to
denote the column number of the original matrix, not of the current,
reduced, matrix. Therefore, the column numbers of the original matrix
are passed as colnames and referenced when the permanent is extended.
@c 
##  1:n doesn't change, even if n is changed
##  within the loop 
for (i in 1:n) {
  ##  reject if any row with only zeros
  if (prod(rt)==0) {
    accept &lt;- FALSE
    break
  ##  trap special case of 1 by 1 matrix  
  } else if (n==1) {
    elt &lt;- 1
  } else {
    &lt;&lt;random sample column&gt;&gt;
  }
  ##  update permutation vector
  perm &lt;- c(perm, indizes[elt])
  if (n &gt; 1) {
    &lt;&lt;reduce matrix to sampled minor&gt;&gt;
    if (is.matrix(at)) {
      ##  re-calculate row sums and dimension
      rt &lt;- apply(at, 1, sum)
      n &lt;- nrow(at)
      ##  trap special case of 1 by 1 matrix  
    } else {
      ##  don't reduce further, just
      ##  re-calculate row sums and dimension
      rt &lt;- at
      n &lt;- 1
    }   
  }
}  
break  #  proper permutation sampled
</t>
<t tx="hannes.20050214071713">&lt;&lt; Details &gt;&gt; 
</t>
<t tx="hannes.20050214072408">@ 

The modified algorithm does not take the rows in the given order, 
but picks a row by certain criteria. 

@c
</t>
<t tx="hannes.20050214072408.1">@
The first criterion addresses possible separators, 
that is, sets of few columns that, when removed, 
leave the matrix with a block diagonal structure. 
If one views the matrix as an adjacency matrix of
a graph, the task is now to look for waists of the
graph. 

As one can rely on the matrix having a tube structure,
a primitive algorithm is sufficient to look for 
waists in the corresponding graph.
These columns are detected by counting the number 
of ones below the main diagonal.

@c
###  selection criteria for separator
firstcrit &lt;- function(mat) {
  n &lt;- nrow(mat)
  lowerdiag &lt;- outer(1:n, 1:n, "&gt;=")
  ##  the most desirable is the column _after_ the one
  ##  with the least ones from the main diagonal
  apply(cbind(rep(1,n), mat[,1:n-1])*
        ##  do not choose columns with 1s to the bottom
        ##  therefore heavy weight to bottom row
        array(rep(c(rep(1, n-1), n), n), dim=c(n,n)) *
        lowerdiag, 2, sum) 
}
</t>
<t tx="hannes.20050214072408.2">@ 

If one aims to split a matrix into separate blocks, 
one would like the blocks to have the same size. 
Therefore, the second criterion favors
the middle rows and therefore is a convex, 
symmetric function of the row index.

@c
secondcrit &lt;- function(mat) {
    n &lt;- nrow(mat)
    (1:n) * (n:1)/(n + 1)/(n + 1) * 8
}
</t>
<t tx="hannes.20050214072802">@ 

The row with the minimal sum of first and second criterion is selected. 

@c
selectrow &lt;- function(mat) {
  which.min(firstcrit(mat)-secondcrit(mat))
}
</t>
<t tx="hannes.20050214073943">@ 
The main idea of speeding up the process is to 
select the rows to reduce the matrix such as to
obtain minors with a block-diagonal structure. 
If a block-diagonal structure is detected, the
algorithm calls itself recursively on the blocks
and pastes the results together to get the whole
permutation.

Again, this is not a function that works on 
general symmetric 0-1 matrices. 
Instead of globally searching for a block structure, 
it looks if subsequent rows have at least one zero 
in either column.
@c
seps &lt;- function(mat) {
    if (dim(mat)[1] &lt; 3) 
        NULL
    else {
        n &lt;- nrow(mat)
        sumoff &lt;- c(sum(mat[2:n, 1] + mat[1, 2:n]), sapply(2:(n - 
            1), function(i) {
            sum(mat[1:i, (i + 1):n]) + sum(mat[(i + 1):n, 1:i])
        }))
        which(sumoff == 0)
    }
}
</t>
<t tx="hannes.20050214074544">@ 


The next row is selected according to the two criteria, and the column
is sampled according to the weights obtained by equation \ref{eq:huber-g}. If the element beyond the matrix rows is
selected, the current sample is rejected and restarted.
 
@c
ResperClotInner &lt;- function(mat) {
  reject &lt;- 0
  repeat {
    &lt;&lt;try and sample until proper permutation&gt;&gt;
  }
  list(perm=perm, reject=reject)
}
</t>
<t tx="hannes.20050214074544.2">@ 

Finally, a wrapper function is written that reduces the permanent data
structure to a single permanent vector, as in the function for the
Huber algorithm.

@c
ResperClot &lt;- function(mat) {
  a &lt;- ResperClotInner(mat)
  a$perm &lt;- a$perm[order(a$perm[,1]), 2]
  a
}
</t>
<t tx="hannes.20050214080843">@
The permutation structure is initialized as a two-column
matrix, the first column denoting the row indices and the
second the column indices. The outer wrapper function
converts these to a permutation vector.

The acceptance flag is initialized to \verb+TRUE+, the 
row sums and dimension are calculated. The rownames and
the colnames are initialized to the indices if they are 
not present. If there are rownames and colnames already,
do not overwrite them as the function can be called 
recursively.

Then, sample, reject, and try again until a proper sample
is selected.  
@c
perm &lt;- c(NULL, NULL)
accept &lt;- TRUE
n &lt;- nrow(mat)
if (is.null(colnames(mat))) {
  colnames(mat) &lt;- 1:n
  rownames(mat) &lt;- 1:n
}
at &lt;- mat
rt &lt;- apply(at, 1, sum)
repeat {
  &lt;&lt;see how far you get without failing&gt;&gt;
}
if (accept) {
  break
  } 
else {
  reject &lt;- reject+1
}

    </t>
<t tx="hannes.20050214080843.1">@
First, trap the special case where the matrix has only 
one dimension. In this case, fill the permanent structure
with the last row and column index, and return successfully.
@c
if (n==1) {
  perm &lt;- rbind(perm, as.numeric(c(rownames(at), colnames(at))))
  break
}
@
If the matrix contains only ones, one can sample from
the unrestricted set of permutations.
@c
else if (prod(at)==1) {
  &lt;&lt;sample from unrestricted set of permutations&gt;&gt;
  ## exit successfully 
  break
} 
@
If there is a block-diagonal structure, call 
function recursively on the blocks.
@c
else if (length(seps &lt;- seps(at))&gt;0) {
  &lt;&lt;call function recursively on the blocks&gt;&gt;
  ##  exit successfully
  break 
}  
@
The next test is on the main diagonal containing a 0. By virtue of the
tube structure of the original matrix, if any of its minors has a 0 in
the main diagonal, this minor necessarily contains a rectangular
submatrix of only 0s that includes either both the first row and the
last column or the last row and the first column. This is a sufficient condition for the permanent of this minor being 0 (a result cited in \cite{minc1978}), which in turn is reason enough to reject and restart.
@c
else if (prod(diag(at))==0) {
  accept &lt;- FALSE
  break
}
@
  Now that we've handled the special cases,
  let's treat the normal case.
@c    
else {
  &lt;&lt;select row and column to delete&gt;&gt;
  ##  update permutation structure
  perm &lt;- rbind(perm, as.numeric(c(rownames(at)[i],
                                   colnames(at)[j])))
  &lt;&lt;reduce matrix to minors&gt;&gt;  
  if (dim(at)[1]==0) break
}</t>
<t tx="hannes.20050214080843.2">@
In the unrestricted case, one can simply use R's \verb+sample()+
algorithm. which is used for the column index column of the
permutation structure, which is then updated row-wise by the
permutation of the current matrix.
@c
unrestricted &lt;- array(as.numeric(c(rownames(at),
                                   sample(colnames(at),
                                          size=ncol(at)))),
                      dim=c(nrow(at),2))
perm &lt;- rbind(perm, unrestricted) 
</t>
<t tx="hannes.20050214081550">bstart &lt;- c(1, seps+1)
bend &lt;- c(seps, n)
for (i in (1:length(bstart))) {
  ## recursively call the function on the blocks
  a &lt;- ResperClotInner(at[bstart[i]:bend[i],
                            bstart[i]:bend[i], drop=FALSE])
  perm &lt;- rbind(perm, a$perm)                          
  reject &lt;- reject+a$reject
}
</t>
<t tx="hannes.20050214081952">@
The row is sampled according to the optimality
criteria. The column is sampled at random.
If the element beyond the matrix columns is
selected, the accept-reject algorithm rejects.
@c
i &lt;- selectrow(at) 
Mrt &lt;- HuberProbs(at, i)
j &lt;- sample(n+1, 1, prob=Mrt)
if (j==n+1) {
  accept &lt;- FALSE
  break
}</t>
<t tx="hannes.20050214083309">at &lt;- at[-i,-j, drop=FALSE]
n &lt;- n-1
</t>
<t tx="hannes.20050216053950">@
\subsection{Original accept and reject algorithm}
\label{sec:byrow-sample}
@c
@others
</t>
<t tx="hannes.20050216053950.1">@
\subsection{The separating accept and reject algorithm}
\label{sec:clot-sample}
@c
@others
</t>
<t tx="hannes.20050217060342">export(ResperByrow, ResperClot, WithinDeltaMat)</t>
<t tx="hannes.20050217062348">@
The most important application of a tube matrix
in this context is the one that determines 
permutability between elements that are close
to each other. Therefore, a function is desirable that
returns such a matrix from an ordered sequence
$(t_i)_{i\in \{1,\ldots , n\}}$ and a lag $\Delta$. 
The rows and columns of the matrix 
correspond to the elements in the ordered seqence,
and an element $a_{ij}$ is set to \verb+TRUE+
exactly when $|t_i-t_j| &lt; \Delta$. The Boolean entries
in the matrix are converted to 0s and 1s when arithmetic
functions are applied to them.  
@c
WithinDeltaMat &lt;- function(seq, delta) {
  outer(seq, seq+delta, '&lt;') &amp; outer(seq+delta, seq, '&gt;')
}
</t>
<t tx="hannes.20050217062348.2"></t>
<t tx="hannes.20050217075724">Package: &lt;&lt;Package&gt;&gt;
Title: &lt;&lt;Title&gt;&gt;
Version: &lt;&lt;Version&gt;&gt;
Date: &lt;&lt;Date&gt;&gt;
Author: &lt;&lt;Author&gt;&gt;
Description: &lt;&lt;Description&gt;&gt;
Maintainer: &lt;&lt;Maintainer&gt;&gt;
License: &lt;&lt;License&gt;&gt;
Encoding: &lt;&lt;Encoding&gt;&gt; </t>
<t tx="hannes.20050217081922">resper
</t>
<t tx="hannes.20050217081922.1">Sampling from restricted permutations
</t>
<t tx="hannes.20050217081922.2">0.3.2
</t>
<t tx="hannes.20050217081922.3">Johannes Hüsing
</t>
<t tx="hannes.20050217081922.4">Two accept-and-reject algorithms to sample from permutations
</t>
<t tx="hannes.20050217081922.5">Johannes Hüsing &lt;johannes@huesing.name&gt;
</t>
<t tx="hannes.20050217081922.6">GNU GPL Version 2 or newer.
</t>
<t tx="hannes.20050217082529">2005-02-17
</t>
<t tx="hannes.20050217083718"></t>
<t tx="hannes.20050217083718.1">@language latex

\name{ResperByrow}
\alias{ResperByrow}
%- Also NEED an '\alias' for EACH other topic documented here.
\encoding{&lt;&lt;Encoding&gt;&gt;}
\title{&lt;&lt;Title&gt;&gt;}
\description{
  &lt;&lt;Description&gt;&gt;
}
\usage{
ResperByrow(mat)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  &lt;&lt;Arguments&gt;&gt;
}
\details{
  &lt;&lt;Details&gt;&gt;
  }
\value{
  &lt;&lt;Value&gt;&gt;
}
\references{ }
\author{ &lt;&lt;Author&gt;&gt; }
\note{ &lt;&lt;Notes&gt;&gt; }

\seealso{ &lt;&lt;See Also&gt;&gt; }
\examples{
&lt;&lt;Examples&gt;&gt;
}
\keyword{datagen}</t>
<t tx="hannes.20050217084055">Sample from a set of restricted permutations</t>
<t tx="hannes.20050217084055.1">Sample from a set of permutations restricted by a Boolean 
or 0-1 matrix \eqn{A}{A}, where the rows correspond to the original
elements and the columns to the positions in the permutation.
\eqn{A_{i,j}=1}{A_{i,j}=1} means that the \eqn{i}{i}th element may occur at the
\eqn{j}{j}th position in the permuted sequence.    </t>
<t tx="hannes.20050217085507">\code{link{WithinDeltaMat}}, \code{link{ResperClot}}  </t>
<t tx="hannes.20050217085507.1">\item{mat}{&lt;&lt;mat&gt;&gt;}</t>
<t tx="hannes.20050217085507.2">A Boolean or 0-1 matrix. A permutation can only be
gemerated if at least one element in each row and
each column is equal to 1. </t>
<t tx="hannes.20050217092459">##  No element may be shifted by more than two 
##  positions

mat &lt;- toeplitz(c(rep(1,3), rep(0,3)))
perm &lt;- ResperByrow(mat)
perm

  
</t>
<t tx="hannes.20050217092622.1">A sequence of values corresponding to the row indices 
of \verb+t+.</t>
<t tx="hannes.20050217092646">The function does not check if the input is a proper 0-1 matrix.</t>
<t tx="hannes.20050217094742">@language latex

\name{ResperClot}
\alias{ResperClot}
%- Also NEED an '\alias' for EACH other topic documented here.
\encoding{&lt;&lt;Encoding&gt;&gt;}
\title{&lt;&lt;Title&gt;&gt;}
\description{
  &lt;&lt;Description&gt;&gt;
}
\usage{
ResperClot(mat)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  &lt;&lt;Arguments&gt;&gt;
}
\details{
  &lt;&lt;Details&gt;&gt;
  }
\value{
  &lt;&lt;Value&gt;&gt;
}
\references{ }
\author{ &lt;&lt;Author&gt;&gt; }
\note{ &lt;&lt;Notes&gt;&gt; }

\seealso{ &lt;&lt;See Also&gt;&gt; }
\examples{
&lt;&lt;Examples&gt;&gt;
}
\keyword{datagen}</t>
<t tx="hannes.20050217094742.1">Sample from a set of time window restricted permutations</t>
<t tx="hannes.20050217094742.2">Sample from a set of permutations of points in time, where two elements cannot be juxtaposed if the lag between them is longer than a predefined time window</t>
<t tx="hannes.20050217094742.3">\item{mat}{&lt;&lt;mat&gt;&gt;}</t>
<t tx="hannes.20050217094742.4">A Boolean or 0-1 matrix with a ```tube'' structure 
following the rule: 
\deqn{i&lt;j \Leftrightarrow A_{i,j+1}\le A_{i,j}\le A_{i+1,j}}{i&lt;j ==&gt; A_{i,j+1} &lt;= A_{i,j} &lt;= A_{i+1,j}}
(for the Boolean matrix, replace \eqn{\le}{&lt;=} with \eqn{\Rightarrow}{==&gt;}). 
The rows and columns of the matrix can be interpreted as
time points, and  corresponds to
the situations where the elements are time points, and 
a permutation is not valid if an element \eqn{i}{i} occurs
before another one \eqn{j}{j} when \eqn{t(i)&gt;t(j)+\Delta}{t(i)&gt;t(j)+delta}}. The matrix
is given by the sequence and \eqn{\Delta}{delta}.</t>
<t tx="hannes.20050217094742.5">@
This function uses an accept-reject algorithm that tries
to break up the matrix into a block-diagonal structure.
It selects a row whose elimination will bring the matrix
closer to a block-diagonal structure, samples an appropriate
cell from the 1s in the row (denoting the position to
which the element corresponding to the row will be shifted), eliminates the cell row and column from the matrix and
reiterates the algorithm on the minor. The sampling
weights are constructed by an envelope probability
discovered by \cite{huber2003}, which guarantees that the
sum of weights over all minors is less than or equal
to the weight of the matrix itself. If the algorithm
samples the ``less than'' part, it will reject and
restart the current attempt.
@c  </t>
<t tx="hannes.20050217094742.6">A sequence of values corresponding to the row indices 
of \verb+t+.</t>
<t tx="hannes.20050217094742.7">The matrix is not checked for a tube structure
when calling the function.</t>
<t tx="hannes.20050217094742.8">\code{\link{WithinDeltaMat}}, \code{\link{ResperByrow}}  </t>
<t tx="hannes.20050217094742.10">##  No element may be shifted by more than two 
##  positions

mat &lt;- toeplitz(c(rep(1,3), rep(0,3)))
perm &lt;- ResperClot(mat)
perm

  
</t>
<t tx="hannes.20050217100004">This function uses an accept-reject algorithm.
It selects the first row, samples an appropriate 
cell from the 1s in the row (denoting the position to 
which the element corresponding to the row will be shifted), eliminates the cell row and column from the matrix and 
reiterates the algorithm on the minor. The sampling 
weights are constructed by an envelope probability 
discovered by \cite{huber2003}, which guarantees that the 
sum of weights over all minors is less than or equal
to the weight of the matrix itself. If the algorithm
samples the ``less than'' part, it will reject and
restart the current attempt.  </t>
<t tx="hannes.20050222080110">@language latex

\name{WithinDeltaMat}
\alias{WithinDeltaMat}
%- Also NEED an '\alias' for EACH other topic documented here.
\encoding{&lt;&lt;Encoding&gt;&gt;}
\title{&lt;&lt;Title&gt;&gt;}
\description{
  &lt;&lt;Description&gt;&gt;
}
\usage{
WithinDeltaMat(seq, delta)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  &lt;&lt;Arguments&gt;&gt;
}
\details{
  &lt;&lt;Details&gt;&gt;
  }
\value{
  &lt;&lt;Value&gt;&gt;
}
\references{ }
\author{ &lt;&lt;Author&gt;&gt; }
\note{ &lt;&lt;Notes&gt;&gt; }

\seealso{ &lt;&lt;See Also&gt;&gt; }
\examples{
&lt;&lt;Examples&gt;&gt;
}
\keyword{datagen}% at least one, from doc/KEYWORDS
</t>
<t tx="hannes.20050222080315">Generating an adjacency matrix for |x-y| &lt; delta</t>
<t tx="hannes.20050222080839">Given a sequence of numbers and a "window" delta,
the function generates an adjacency matrix for the
elements of the sequence and the relation |x-y| &lt; delta,
where x and y are two elements of the sequence.
</t>
<t tx="hannes.20050222080839.1">\item{seq}{&lt;&lt;seq&gt;&gt;}
\item{delta}{&lt;&lt;delta&gt;&gt;}</t>
<t tx="hannes.20050222080839.2">an ordered sequence of numbers</t>
<t tx="hannes.20050222080839.3">a nonnegative number</t>
<t tx="hannes.20050222081106"></t>
<t tx="hannes.20050222081106.1">A matrix of Boolean values
(\code{TRUE} for a pair of elements whose distance
is less than \code{delta}).</t>
<t tx="hannes.20050222082057"></t>
<t tx="hannes.20050222082057.1"></t>
<t tx="hannes.20050222170736">##  this returns a Toeplitz matrix

WithinDeltaMat(1:10, 4)

##  this generates a matrix from a Poisson sequence

run &lt;- cumsum(rgamma(100, 1))
WithinDeltaMat(run, 3)</t>
<t tx="hannes.20050323152429"></t>
<t tx="hannes.20050323152429.1">% -*- mode: noweb; noweb-default-code-mode: R-mode; -*-
\documentclass{scrartcl}
\usepackage{Sweave}
\begin{document}
%% \VignetteIndexEntry{ResperByrow}
%% \VignetteIndexEntry{ResperClot}
\section{Some simulations}

&lt;&lt;print=FALSE&gt;&gt;=
library(resper)
@

First of all, lets check if the algorithm samples the permutations
with similar frequencies. To that end, we build a tridiagonal matrix,
which would correspond to a run of equidistant numbers and a lag that
covers up to three numbers at once.

&lt;&lt;print=TRUE&gt;&gt;=
m &lt;- toeplitz(c(rep(1,2), rep(0,5)))
print(m)
@ 

A nice result is that the permanent of an $n-dimensional$ tridiagonal
matrix is the $n+1$th Fibonacci number. The algorithm therefore should sample from 21 realizations of the permutation with probability $1/21$ each. Let's sample with the classical algorithm:


&lt;&lt;&gt;&gt;=
anziter &lt;- 1000
byrow.times &lt;- NULL
byrow.perms &lt;- NULL
byrow.rejects &lt;- NULL

for (i in 1:anziter) {
  byrow.times &lt;- rbind(byrow.times, system.time( p &lt;- ResperByrow(m) ))
  byrow.perms &lt;- rbind(byrow.perms, p$perm)
  byrow.rejects &lt;- c(byrow.rejects, p$reject)
}
@ 

Now let's look at the result. The permutations are first mapped to single elements that are distinguished between one another. As no number is greater than 9, one can simply convert the permutations into eight-digit numbers.

&lt;&lt;print=TRUE&gt;&gt;=
pn &lt;- apply(t(byrow.perms)*10**(6:0), 2, sum)
table(pn)
@  

The computation times that this has taken are logged by attempt. Obviously, the distribution of times is very skewed. 

&lt;&lt;echo=TRUE, print=TRUE&gt;&gt;=
summary(byrow.times)
@ 

This is caused by the roughly geometrical distribution of the number of rejections. 

&lt;&lt;echo=TRUE, fig=TRUE&gt;&gt;=
plot(table(byrow.rejects))
@ 

Let's see if the clotting algorithm performs better.

&lt;&lt;&gt;&gt;=
anziter &lt;- 1000
clot.times &lt;- NULL
clot.perms &lt;- NULL
clot.rejects &lt;- NULL
for (i in 1:anziter){
  clot.times &lt;- rbind(clot.times,   system.time( p &lt;- ResperClot(m) ))
  clot.perms &lt;- rbind(clot.perms, p$perm)
  clot.rejects &lt;- c(clot.rejects, p$reject)
}
@ 

The tabulation of the permutation samples:

&lt;&lt;echo=TRUE, print=TRUE&gt;&gt;=
pn &lt;- apply(t(clot.perms)*10**(6:0), 2, sum)
table(pn)
@ 

The summary of the computing time:

&lt;&lt;echo=TRUE, print=TRUE&gt;&gt;=
summary(clot.times)
@ 

And finally, the bar chart of the rejections:

&lt;&lt;echo=TRUE, fig=TRUE&gt;&gt;=
plot(table(clot.rejects))
@ 

\end{document}
</t>
<t tx="hannes.20050329072710"></t>
<t tx="hannes.20050329072710.1">resper:::HuberGNonRecursive(5)
resper:::HuberGNonRecursive(280)
</t>
<t tx="hannes.20050329073523">getwd()
library(resper)

set.seed(seed=1, kind="default")

mklein &lt;- toeplitz(c(1,1,0,0,0,0,0))
mgross &lt;- toeplitz(c(rep(1,4), rep(0,36)))

mzufall &lt;- WithinDeltaMat(cumsum(runif(20)), 2)

@others</t>
<t tx="hannes.20050329074025">resper:::HuberProbs(mklein, 1)
resper:::HuberProbs(mklein, 4)
resper:::HuberProbs(mgross, 1)
resper:::HuberProbs(mgross, 14)
</t>
<t tx="hannes.20050512202734">utf-8</t>
</tnodes>
</leo_file>
